<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BICEP · Parallel Path Sampler Demo</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --bg: #0a0a0a;
      --text: #e5e7eb;
      --text-muted: #6b7280;
      --accent: #10b981;
      --accent-glow: rgba(16, 185, 129, 0.5);
      --obstacle: rgba(239, 68, 68, 0.7);
      --border: rgba(255,255,255,0.08);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      line-height: 1.6;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle {
      color: var(--text-muted);
      margin-bottom: 2rem;
      font-size: 0.95rem;
    }
    
    /* Controls */
    .controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }
    
    input[type="range"] {
      width: 100px;
      height: 4px;
      background: #374151;
      outline: none;
      border-radius: 2px;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--accent);
      cursor: pointer;
      border-radius: 50%;
    }
    
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.875rem;
    }
    
    button:hover {
      background: #059669;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .mode-toggle {
      display: flex;
      gap: 0.25rem;
      background: #111827;
      padding: 0.25rem;
      border-radius: 6px;
    }
    
    .mode-btn {
      background: transparent;
      color: var(--text-muted);
      padding: 0.375rem 0.75rem;
      border-radius: 4px;
      font-size: 0.813rem;
    }
    
    .mode-btn.active {
      background: #374151;
      color: var(--text);
    }
    
    /* Canvas container */
    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 840px;
      margin: 0 auto;
      background: #111827;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .canvas-stack {
      position: relative;
      width: 100%;
      height: 520px;
    }
    
    .canvas-stack canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* Stats overlay */
    .stats-overlay {
      position: absolute;
      top: 1rem;
      right: 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      max-width: 300px;
      justify-content: flex-end;
    }
    
    .stat-pill {
      background: rgba(17, 24, 39, 0.9);
      backdrop-filter: blur(8px);
      color: var(--text);
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
    }
    
    .stat-pill strong {
      color: var(--accent);
      font-weight: 600;
    }
    
    /* Legend */
    .legend {
      display: flex;
      gap: 1.5rem;
      margin-top: 1rem;
      font-size: 0.813rem;
      color: var(--text-muted);
      justify-content: center;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }
    
    /* Presets */
    .presets {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .preset-btn {
      background: #1f2937;
      font-size: 0.75rem;
      padding: 0.375rem 0.75rem;
    }
    
    .preset-btn:hover {
      background: #374151;
    }
    
    /* Math toggle */
    .math-toggle {
      margin-top: 2rem;
      border-top: 1px solid var(--border);
      padding-top: 2rem;
    }
    
    .math-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    
    .math-header:hover {
      color: var(--text);
    }
    
    .math-content {
      display: none;
      margin-top: 1rem;
      padding: 1rem;
      background: #111827;
      border-radius: 6px;
      font-size: 0.875rem;
      line-height: 1.8;
    }
    
    .math-content.show {
      display: block;
    }
    
    .math-content code {
      color: var(--accent);
      font-family: monospace;
    }
    
    .back-link {
      position: fixed;
      top: 2rem;
      left: 2rem;
      color: var(--text-muted);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      transition: color 0.2s ease;
    }
    
    .back-link:hover {
      color: var(--accent);
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M19 12H5M5 12l7 7M5 12l7-7"/>
    </svg>
    Back
  </a>

  <div class="container">
    <h1>BICEP Path Sampler</h1>
    <p class="subtitle">Watch thousands of particles explore paths in parallel</p>

    <div class="controls">
      <div class="mode-toggle">
        <button class="mode-btn active" data-mode="particles">Particles</button>
        <button class="mode-btn" data-mode="heatmap">Heatmap</button>
        <button class="mode-btn" data-mode="paths">Top Paths</button>
      </div>
      
      <div class="control-group">
        <label>Particles:</label>
        <input type="range" id="particles" min="100" max="5000" value="2000" step="100">
        <span id="particles-value">2000</span>
      </div>
      
      <div class="control-group">
        <label>Sigma:</label>
        <input type="range" id="sigma" min="0.1" max="1.5" value="0.6" step="0.1">
        <span id="sigma-value">0.6</span>
      </div>
      
      <button id="run-btn">Run Simulation</button>
      <button id="reset-btn">Clear</button>
    </div>

    <div class="canvas-container">
      <div class="canvas-stack">
        <canvas id="bg-canvas"></canvas>
        <canvas id="obs-canvas"></canvas>
        <canvas id="sim-canvas"></canvas>
        <canvas id="path-canvas"></canvas>
      </div>
      
      <div class="stats-overlay">
        <div class="stat-pill">Active: <strong id="stat-active">0</strong></div>
        <div class="stat-pill">Success: <strong id="stat-success">0</strong></div>
        <div class="stat-pill">Step: <strong id="stat-steps">0</strong></div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #10b981"></div>
        <span>Start → Goal</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: rgba(239,68,68,0.7)"></div>
        <span>Obstacles (click to draw)</span>
      </div>
    </div>

    <div class="presets">
      <button class="preset-btn" data-preset="corridor">Narrow Corridor</button>
      <button class="preset-btn" data-preset="maze">Maze</button>
      <button class="preset=btn" data-preset="sparse">Sparse</button>
      <button class="preset-btn" data-preset="dense">Dense</button>
    </div>

    <div class="math-toggle">
      <div class="math-header">
        <span>▶</span>
        <span>Show math</span>
      </div>
      <div class="math-content">
        Each particle follows Brownian bridge dynamics with goal attraction:<br>
        <code>x_{k+1} = x_k + (goal - x_k)/(N - k) + σ·Z_k</code><br><br>
        Where σ controls exploration vs exploitation, and Z_k is Gaussian noise.
        BICEP runs thousands of these trajectories in parallel to find optimal paths.
      </div>
    </div>
  </div>

  <script>
    // Canvas setup
    const bgCanvas = document.getElementById('bg-canvas');
    const obsCanvas = document.getElementById('obs-canvas');
    const simCanvas = document.getElementById('sim-canvas');
    const pathCanvas = document.getElementById('path-canvas');
    
    const bgCtx = bgCanvas.getContext('2d');
    const obsCtx = obsCanvas.getContext('2d');
    const simCtx = simCanvas.getContext('2d');
    const pathCtx = pathCanvas.getContext('2d');
    
    // Grid settings
    const gridSize = 40;
    const cellSize = 13;
    let grid = [];
    let particles = [];
    let winners = [];
    let heatmap = new Float32Array(gridSize * gridSize);
    let mode = 'particles';
    let running = false;
    let step = 0;
    
    // Start and goal regions
    const startCells = [];
    const goalCells = [];
    
    // Initialize canvases
    function initCanvases() {
      const width = gridSize * cellSize;
      const height = gridSize * cellSize;
      
      [bgCanvas, obsCanvas, simCanvas, pathCanvas].forEach(canvas => {
        canvas.width = width;
        canvas.height = height;
      });
      
      // Draw background grid once
      bgCtx.fillStyle = '#0a0a0a';
      bgCtx.fillRect(0, 0, width, height);
      
      // Grid lines
      bgCtx.strokeStyle = 'rgba(255,255,255,0.03)';
      bgCtx.lineWidth = 1;
      for (let i = 0; i <= gridSize; i++) {
        bgCtx.beginPath();
        bgCtx.moveTo(i * cellSize, 0);
        bgCtx.lineTo(i * cellSize, height);
        bgCtx.stroke();
        
        bgCtx.beginPath();
        bgCtx.moveTo(0, i * cellSize);
        bgCtx.lineTo(width, i * cellSize);
        bgCtx.stroke();
      }
    }
    
    function initGrid() {
      grid = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
      
      // Define start and goal regions
      startCells.length = 0;
      goalCells.length = 0;
      
      for (let y = 10; y < 30; y++) {
        for (let x = 0; x < 3; x++) {
          startCells.push([x, y]);
        }
        for (let x = gridSize - 3; x < gridSize; x++) {
          goalCells.push([x, y]);
        }
      }
      
      particles = [];
      winners = [];
      heatmap.fill(0);
      step = 0;
      
      drawObstacles();
      drawStartGoal();
    }
    
    function drawStartGoal() {
      obsCtx.clearRect(0, 0, obsCanvas.width, obsCanvas.height);
      
      // Start region
      obsCtx.fillStyle = 'rgba(16,185,129,0.2)';
      startCells.forEach(([x, y]) => {
        obsCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      });
      
      // Goal region
      obsCtx.fillStyle = 'rgba(16,185,129,0.2)';
      goalCells.forEach(([x, y]) => {
        obsCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      });
      
      drawObstacles();
    }
    
    function drawObstacles() {
      obsCtx.fillStyle = 'rgba(239,68,68,0.7)';
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          if (grid[x][y]) {
            obsCtx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);
          }
        }
      }
    }
    
    function initParticles() {
      const numParticles = parseInt(document.getElementById('particles').value);
      particles = [];
      
      for (let i = 0; i < numParticles; i++) {
        const start = startCells[Math.floor(Math.random() * startCells.length)];
        particles.push({
          x: start[0] + 0.5,
          y: start[1] + 0.5,
          path: [[start[0], start[1]]],
          alive: true,
          cost: 0
        });
      }
    }
    
    function updateParticles() {
      const sigma = parseFloat(document.getElementById('sigma').value);
      const maxSteps = 300;
      
      particles.forEach(p => {
        if (!p.alive || p.reached) return;
        
        // Find nearest goal
        let minDist = Infinity;
        let nearestGoal = goalCells[0];
        goalCells.forEach(g => {
          const dist = Math.sqrt((g[0] - p.x) ** 2 + (g[1] - p.y) ** 2);
          if (dist < minDist) {
            minDist = dist;
            nearestGoal = g;
          }
        });
        
        // Brownian bridge dynamics
        const remaining = Math.max(1, maxSteps - step);
        const pullX = (nearestGoal[0] + 0.5 - p.x) / remaining;
        const pullY = (nearestGoal[1] + 0.5 - p.y) / remaining;
        
        // Add noise
        const noiseX = (Math.random() - 0.5) * 2 * sigma;
        const noiseY = (Math.random() - 0.5) * 2 * sigma;
        
        p.x += pullX + noiseX;
        p.y += pullY + noiseY;
        
        // Grid bounds
        p.x = Math.max(0, Math.min(gridSize - 1, p.x));
        p.y = Math.max(0, Math.min(gridSize - 1, p.y));
        
        const gridX = Math.floor(p.x);
        const gridY = Math.floor(p.y);
        
        // Update heatmap
        const idx = gridY * gridSize + gridX;
        heatmap[idx] += 1;
        
        // Check collision
        if (grid[gridX][gridY]) {
          p.alive = false;
        } else {
          p.path.push([gridX, gridY]);
          p.cost++;
          
          // Check if reached goal
          if (goalCells.some(g => g[0] === gridX && g[1] === gridY)) {
            p.reached = true;
            recordWinner(p);
          }
        }
      });
      
      step++;
    }
    
    function recordWinner(particle) {
      winners.push({
        path: particle.path.slice(),
        cost: particle.cost
      });
      
      // Keep top 50 paths
      winners.sort((a, b) => a.cost - b.cost);
      if (winners.length > 50) {
        winners = winners.slice(0, 50);
      }
    }
    
    function drawSimulation() {
      simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
      
      if (mode === 'particles') {
        drawParticles();
      } else if (mode === 'heatmap') {
        drawHeatmap();
      } else if (mode === 'paths') {
        drawTopPaths();
      }
    }
    
    function drawParticles() {
      simCtx.fillStyle = 'rgba(59,130,246,0.6)';
      particles.forEach(p => {
        if (p.alive && !p.reached) {
          simCtx.fillRect(
            p.x * cellSize - 1,
            p.y * cellSize - 1,
            3,
            3
          );
        }
      });
    }
    
    function drawHeatmap() {
      const maxHeat = Math.max(...heatmap);
      if (maxHeat === 0) return;
      
      for (let i = 0; i < heatmap.length; i++) {
        if (heatmap[i] > 0) {
          const x = i % gridSize;
          const y = Math.floor(i / gridSize);
          const intensity = Math.pow(heatmap[i] / maxHeat, 0.5);
          simCtx.fillStyle = `rgba(59,130,246,${0.05 + 0.4 * intensity})`;
          simCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
    }
    
    function drawTopPaths() {
      simCtx.lineWidth = 1.5;
      
      // Draw all paths with varying colors
      winners.forEach((w, i) => {
        if (i === 0) return; // Skip best path (drawn separately)
        
        simCtx.strokeStyle = `hsla(${200 + i * 3}, 70%, 50%, 0.3)`;
        simCtx.beginPath();
        w.path.forEach((pos, j) => {
          const x = pos[0] * cellSize + cellSize / 2;
          const y = pos[1] * cellSize + cellSize / 2;
          if (j === 0) simCtx.moveTo(x, y);
          else simCtx.lineTo(x, y);
        });
        simCtx.stroke();
      });
    }
    
    function drawBestPath() {
      pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
      
      if (winners.length === 0) return;
      
      const best = winners[0].path;
      
      // Draw path with glow
      pathCtx.shadowColor = 'rgba(16,185,129,0.5)';
      pathCtx.shadowBlur = 8;
      pathCtx.strokeStyle = '#10b981';
      pathCtx.lineWidth = 3;
      pathCtx.lineCap = 'round';
      pathCtx.lineJoin = 'round';
      
      pathCtx.beginPath();
      best.forEach((pos, i) => {
        const x = pos[0] * cellSize + cellSize / 2;
        const y = pos[1] * cellSize + cellSize / 2;
        if (i === 0) pathCtx.moveTo(x, y);
        else pathCtx.lineTo(x, y);
      });
      pathCtx.stroke();
      pathCtx.shadowBlur = 0;
      
      // Draw arrowheads
      pathCtx.fillStyle = '#10b981';
      for (let i = 10; i < best.length; i += 10) {
        const curr = best[i];
        const prev = best[i - 1];
        const x = curr[0] * cellSize + cellSize / 2;
        const y = curr[1] * cellSize + cellSize / 2;
        const px = prev[0] * cellSize + cellSize / 2;
        const py = prev[1] * cellSize + cellSize / 2;
        
        const angle = Math.atan2(y - py, x - px);
        
        pathCtx.save();
        pathCtx.translate(x, y);
        pathCtx.rotate(angle);
        pathCtx.beginPath();
        pathCtx.moveTo(0, 0);
        pathCtx.lineTo(-8, 4);
        pathCtx.lineTo(-8, -4);
        pathCtx.closePath();
        pathCtx.fill();
        pathCtx.restore();
      }
    }
    
    function updateStats() {
      const active = particles.filter(p => p.alive && !p.reached).length;
      document.getElementById('stat-active').textContent = active;
      document.getElementById('stat-success').textContent = winners.length;
      document.getElementById('stat-steps').textContent = step;
    }
    
    function animate() {
      if (!running) return;
      
      updateParticles();
      drawSimulation();
      drawBestPath();
      updateStats();
      
      if (particles.filter(p => p.alive && !p.reached).length === 0 || step > 300) {
        running = false;
        document.getElementById('run-btn').textContent = 'Run Simulation';
        document.getElementById('run-btn').disabled = false;
      } else {
        requestAnimationFrame(animate);
      }
    }
    
    // Event handlers
    document.getElementById('run-btn').addEventListener('click', () => {
      if (running) return;
      
      winners = [];
      heatmap.fill(0);
      step = 0;
      initParticles();
      
      running = true;
      document.getElementById('run-btn').textContent = 'Running...';
      document.getElementById('run-btn').disabled = true;
      
      animate();
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      running = false;
      initGrid();
      simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
      pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
      updateStats();
    });
    
    // Mode toggle
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;
        drawSimulation();
      });
    });
    
    // Canvas drawing
    let isDrawing = false;
    obsCanvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      handleDraw(e);
    });
    
    obsCanvas.addEventListener('mousemove', (e) => {
      if (isDrawing) handleDraw(e);
    });
    
    obsCanvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });
    
    function handleDraw(e) {
      const rect = obsCanvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) * gridSize / rect.width);
      const y = Math.floor((e.clientY - rect.top) * gridSize / rect.height);
      
      if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
        const isStart = startCells.some(c => c[0] === x && c[1] === y);
        const isGoal = goalCells.some(c => c[0] === x && c[1] === y);
        
        if (!isStart && !isGoal) {
          grid[x][y] = !grid[x][y];
          drawStartGoal();
        }
      }
    }
    
    // Presets
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        grid = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
        
        switch(preset) {
          case 'corridor':
            for (let x = 5; x < 35; x++) {
              for (let y = 0; y < 8; y++) grid[x][y] = true;
              for (let y = 32; y < 40; y++) grid[x][y] = true;
            }
            break;
          case 'maze':
            for (let i = 0; i < 15; i++) {
              const x = 5 + i * 2;
              for (let y = 5; y < 35; y++) {
                if (Math.random() > 0.3) grid[x][y] = true;
              }
            }
            break;
          case 'sparse':
            for (let i = 0; i < 50; i++) {
              const x = Math.floor(Math.random() * gridSize);
              const y = Math.floor(Math.random() * gridSize);
              const isStart = startCells.some(c => c[0] === x && c[1] === y);
              const isGoal = goalCells.some(c => c[0] === x && c[1] === y);
              if (!isStart && !isGoal) grid[x][y] = true;
            }
            break;
          case 'dense':
            for (let i = 0; i < 200; i++) {
              const x = Math.floor(Math.random() * gridSize);
              const y = Math.floor(Math.random() * gridSize);
              const isStart = startCells.some(c => c[0] === x && c[1] === y);
              const isGoal = goalCells.some(c => c[0] === x && c[1] === y);
              if (!isStart && !isGoal) grid[x][y] = true;
            }
            break;
        }
        
        drawStartGoal();
      });
    });
    
    // Range updates
    document.getElementById('particles').addEventListener('input', (e) => {
      document.getElementById('particles-value').textContent = e.target.value;
    });
    
    document.getElementById('sigma').addEventListener('input', (e) => {
      document.getElementById('sigma-value').textContent = e.target.value;
    });
    
    // Math toggle
    document.querySelector('.math-header').addEventListener('click', () => {
      const content = document.querySelector('.math-content');
      const arrow = document.querySelector('.math-header span:first-child');
      
      content.classList.toggle('show');
      arrow.textContent = content.classList.contains('show') ? '▼' : '▶';
    });
    
    // Initialize
    initCanvases();
    initGrid();
  </script>
</body>
</html>
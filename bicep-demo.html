<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BICEP · Brownian-Inspired CUDA Engine for Parallelisation</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --bg: #0a0a0a;
      --text: #e5e7eb;
      --text-muted: #6b7280;
      --accent: #10b981;
      --accent-glow: rgba(16, 185, 129, 0.5);
      --obstacle: #dc2626;
      --border: rgba(255,255,255,0.08);
      --success: #22c55e;
      --warning: #f59e0b;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1100px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
      background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle {
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
    }
    
    .tagline {
      color: var(--accent);
      margin-bottom: 2rem;
      font-size: 0.875rem;
      font-weight: 500;
    }
    
    /* Main Grid Layout */
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 1.5rem;
      margin-bottom: 1rem;
    }
    
    /* Canvas container */
    .canvas-container {
      position: relative;
      background: #111827;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .canvas-stack {
      position: relative;
      width: 100%;
      height: 520px;
    }
    
    .canvas-stack canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* Floating overlays */
    .seed-overlay {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(16, 185, 129, 0.1);
      backdrop-filter: blur(8px);
      border: 1px solid var(--accent);
      border-radius: 999px;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .seed-overlay:hover {
      background: rgba(16, 185, 129, 0.2);
      transform: scale(1.05);
    }
    
    .seed-overlay strong {
      color: var(--accent);
      font-weight: 600;
    }
    
    /* Performance overlay */
    .perf-overlay {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(17, 24, 39, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      font-size: 0.75rem;
      min-width: 200px;
    }
    
    .perf-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.25rem;
    }
    
    .perf-row:last-child {
      margin-bottom: 0;
    }
    
    .perf-row strong {
      color: var(--accent);
    }
    
    /* Success rate sparkline */
    .sparkline-overlay {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      background: rgba(17, 24, 39, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem;
      width: 200px;
    }
    
    .sparkline-title {
      font-size: 0.65rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }
    
    .sparkline-canvas {
      width: 100%;
      height: 40px;
    }
    
    /* Batch progress */
    .batch-progress {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      background: rgba(17, 24, 39, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      display: none;
    }
    
    .batch-progress.show {
      display: block;
    }
    
    /* Side panel */
    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    /* Controls section */
    .control-section {
      background: rgba(17, 24, 39, 0.5);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 1rem;
    }
    
    .section-title {
      color: var(--accent);
      font-size: 0.875rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
    }
    
    /* Mode toggle */
    .mode-toggle {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .mode-btn {
      background: #1f2937;
      color: var(--text-muted);
      border: 1px solid transparent;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.813rem;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .mode-btn.active {
      background: #374151;
      color: var(--text);
      border-color: var(--accent);
    }
    
    .mode-btn:hover {
      background: #374151;
    }
    
    .mode-caption {
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    
    /* Parameter controls */
    .param-group {
      margin-bottom: 1rem;
    }
    
    .param-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .param-label {
      font-size: 0.813rem;
      color: var(--text);
    }
    
    .param-value {
      font-size: 0.813rem;
      font-weight: 600;
      color: var(--accent);
    }
    
    .param-slider {
      width: 100%;
      height: 4px;
      background: #374151;
      outline: none;
      border-radius: 2px;
      -webkit-appearance: none;
    }
    
    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--accent);
      cursor: pointer;
      border-radius: 50%;
    }
    
    .param-info {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }
    
    /* Action buttons */
    .action-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.625rem 1rem;
      border-radius: 6px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.875rem;
      white-space: nowrap;
    }
    
    button:hover:not(:disabled) {
      background: #059669;
      transform: translateY(-1px);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button.secondary {
      background: #374151;
    }
    
    button.secondary:hover:not(:disabled) {
      background: #4b5563;
    }
    
    /* Presets */
    .preset-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
    }
    
    .preset-btn {
      background: #1f2937;
      color: var(--text);
      font-size: 0.75rem;
      padding: 0.5rem;
      text-align: center;
      border: 1px solid transparent;
      transition: all 0.2s ease;
    }
    
    .preset-btn:hover {
      background: #374151;
      border-color: var(--accent);
    }
    
    /* Advanced controls */
    .advanced-section {
      background: rgba(17, 24, 39, 0.3);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 1rem;
      margin-top: 0.5rem;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }
    
    .checkbox-group label {
      font-size: 0.813rem;
      color: var(--text);
    }
    
    /* Info panels */
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .info-panel {
      background: rgba(17, 24, 39, 0.5);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 1rem;
      font-size: 0.875rem;
    }
    
    .info-title {
      color: var(--accent);
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .info-item {
      margin-bottom: 0.25rem;
      color: var(--text-muted);
    }
    
    .info-item strong {
      color: var(--text);
    }
    
    .formula {
      background: rgba(0,0,0,0.3);
      padding: 0.5rem;
      border-radius: 4px;
      margin: 0.5rem 0;
      font-family: monospace;
      font-size: 0.813rem;
      color: var(--accent);
    }
    
    /* Back link */
    .back-link {
      position: fixed;
      top: 2rem;
      left: 2rem;
      color: var(--text-muted);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      transition: color 0.2s ease;
    }
    
    .back-link:hover {
      color: var(--accent);
    }
    
    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
      
      .info-grid {
        grid-template-columns: 1fr;
      }
      
      .preset-grid {
        grid-template-columns: 1fr;
      }
      
      .action-buttons {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M19 12H5M5 12l7 7M5 12l7-7"/>
    </svg>
    Back
  </a>

  <div class="container">
    <h1>BICEP RL Curriculum</h1>
    <p class="subtitle">High-throughput, deterministic path sampler + RL training system</p>
    <p class="tagline">Same seed → same paths • Train navigation agents on families of worlds</p>

    <div class="main-grid">
      <div class="canvas-container">
        <div class="canvas-stack">
          <canvas id="bg-canvas"></canvas>
          <canvas id="obs-canvas"></canvas>
          <canvas id="sim-canvas"></canvas>
          <canvas id="path-canvas"></canvas>
        </div>
        
        <div class="seed-overlay" id="seed-overlay" title="Click to copy replay link">
          Seed <strong id="seed-value">--</strong> | Map <strong id="map-seed-value">--</strong>
        </div>
        
        <div class="perf-overlay" id="bicep-metrics">
          <div class="perf-row">
            <span>Throughput:</span>
            <span><strong id="throughput">0</strong> p×step/s</span>
          </div>
          <div class="perf-row">
            <span>Frame time:</span>
            <span><strong id="frame-time">0</strong>ms</span>
          </div>
          <div class="perf-row">
            <span>Active/Total:</span>
            <span><strong id="active-count">0</strong>/<strong id="total-count">0</strong></span>
          </div>
          <div class="perf-row">
            <span>Success rate:</span>
            <span><strong id="success-rate">0%</strong></span>
          </div>
          <div class="perf-row">
            <span>Collisions:</span>
            <span><strong id="collision-count">0</strong></span>
          </div>
          <div class="perf-row">
            <span>Stalled:</span>
            <span><strong id="stalled-count">0</strong></span>
          </div>
          <div class="perf-row">
            <span>t/T:</span>
            <span><strong id="step-counter">0</strong>/<strong id="horizon">300</strong></span>
          </div>
        </div>
        
        <div class="perf-overlay" id="rl-metrics" style="display:none; right: 220px;">
          <div class="perf-row">
            <span>Episode:</span>
            <span><strong id="rl-episode">0</strong>/<strong id="rl-total-episodes">100</strong></span>
          </div>
          <div class="perf-row">
            <span>Reward:</span>
            <span><strong id="rl-reward">0.00</strong></span>
          </div>
          <div class="perf-row">
            <span>Success %:</span>
            <span><strong id="rl-success-rate">0%</strong></span>
          </div>
          <div class="perf-row">
            <span>Demo ratio β:</span>
            <span><strong id="current-beta">0.5</strong></span>
          </div>
          <div class="perf-row">
            <span>Avg steps:</span>
            <span><strong id="rl-avg-steps">0</strong></span>
          </div>
        </div>
        
        <div class="sparkline-overlay">
          <div class="sparkline-title">Success Rate vs Time</div>
          <canvas class="sparkline-canvas" id="sparkline-canvas"></canvas>
        </div>
        
        <div class="sparkline-overlay" style="bottom: 80px; width: 250px;">
          <div class="sparkline-title">Cost Distribution (Top-K)</div>
          <canvas class="sparkline-canvas" id="cost-histogram" style="height: 60px;"></canvas>
          <div style="font-size: 0.6rem; color: var(--text-muted); margin-top: 0.25rem;">
            <label title="Risk-aware ranking using obstacle clearance analysis (surrogate for CVaR tail risk)"><input type="checkbox" id="cvar-toggle" style="margin-right: 4px;">CVaR@5% ranking</label>
          </div>
        </div>
        
        <div class="batch-progress" id="batch-progress">
          Processing batch <strong id="current-batch">1</strong> of <strong id="total-batches">1</strong>
        </div>
      </div>
      
      <div class="side-panel">
        <div class="control-section">
          <div class="section-title">Visualization Mode</div>
          <div class="mode-toggle">
            <button class="mode-btn active" data-mode="particles">
              <span>Particles</span>
              <span class="mode-caption">live swarm</span>
            </button>
            <button class="mode-btn" data-mode="heatmap">
              <span>Heatmap</span>
              <span class="mode-caption">visit density</span>
            </button>
            <button class="mode-btn" data-mode="paths">
              <span>Top Paths</span>
              <span class="mode-caption">best K survivors</span>
            </button>
          </div>
          
          <div class="action-buttons">
            <button id="run-btn">Run BICEP</button>
            <button id="reset-btn" class="secondary">Reset</button>
          </div>
          
          <div class="param-group">
            <div class="param-header">
              <span class="param-label">Replay Seed</span>
            </div>
            <input type="text" id="replay-seed" placeholder="Enter seed" style="width: 100%; padding: 0.5rem; margin: 0.25rem 0; border: 1px solid var(--border); border-radius: 4px; background: #1f2937; color: var(--text); font-size: 0.8rem;">
            <div class="action-buttons" style="margin-top: 0.5rem;">
              <button id="replay-btn" class="secondary">Replay</button>
              <button id="random-seed-btn" class="secondary">New Seed</button>
            </div>
            <div class="param-info">Deterministic reproduction</div>
          </div>
        </div>
        
        <div class="control-section">
          <div class="section-title">BICEP Parameters</div>
          
          <div class="param-group">
            <div class="param-header">
              <span class="param-label">K (particles)</span>
              <span class="param-value" id="particles-value">5000</span>
            </div>
            <input type="range" class="param-slider" id="particles" min="1000" max="20000" value="5000" step="1000">
            <div class="param-info">Parallel trajectories</div>
          </div>
          
          <div class="param-group">
            <div class="param-header">
              <span class="param-label">μ (drift strength)</span>
              <span class="param-value" id="drift-value">1.0</span>
            </div>
            <input type="range" class="param-slider" id="drift" min="0.1" max="3.0" value="1.0" step="0.1">
            <div class="param-info">Goal pull: μ·(goal-x)/(T-t)</div>
          </div>
          
          <div class="param-group">
            <div class="param-header">
              <span class="param-label">σ (noise scale)</span>
              <span class="param-value" id="sigma-value">0.8</span>
            </div>
            <input type="range" class="param-slider" id="sigma" min="0.1" max="2.0" value="0.8" step="0.1">
            <div class="param-info">Exploration: σ·√Δt·Z</div>
          </div>
          
          <div class="param-group">
            <div class="param-header">
              <span class="param-label">T (horizon)</span>
              <span class="param-value" id="horizon-value">300</span>
            </div>
            <input type="range" class="param-slider" id="horizon-slider" min="100" max="500" value="300" step="50">
            <div class="param-info">Max steps, Δt = 1/T</div>
          </div>
        </div>
        
        <div class="control-section">
          <div class="section-title">Advanced Options</div>
          <div class="advanced-section">
            <div class="checkbox-group">
              <input type="checkbox" id="antithetic">
              <label for="antithetic">Antithetic sampling</label>
            </div>
            <div class="param-info">Pairs: (Z, -Z) halve variance</div>
            
            <div class="param-group" style="margin-top: 1rem;">
              <div class="param-header">
                <span class="param-label" title="Correlation between X and Y noise components: ρ=0 (independent), ρ>0 (positive correlation)">Correlation ρ</span>
                <span class="param-value" id="correlation-value">0.0</span>
              </div>
              <input type="range" class="param-slider" id="correlation" min="-0.9" max="0.9" value="0" step="0.1">
              <div class="param-info">Noise correlation: Y = ρX + √(1-ρ²)Z</div>
            </div>
            
            <div class="param-group">
              <div class="param-header">
                <span class="param-label">Wind θ</span>
                <span class="param-value" id="wind-value">0°</span>
              </div>
              <input type="range" class="param-slider" id="wind-angle" min="0" max="360" value="0">
            </div>
            
            <div class="param-group">
              <div class="param-header">
                <span class="param-label">Wind strength</span>
                <span class="param-value" id="wind-str-value">0.0</span>
              </div>
              <input type="range" class="param-slider" id="wind-strength" min="0" max="1" value="0" step="0.1">
            </div>
            
            <div class="param-group">
              <div class="param-header">
                <span class="param-label">Batch size</span>
                <span class="param-value" id="batch-value">2000</span>
              </div>
              <input type="range" class="param-slider" id="batch-size" min="500" max="5000" value="2000" step="500">
              <div class="param-info">Streaming chunks (avoid OOM)</div>
            </div>
          </div>
        </div>
        
        <div class="control-section">
          <div class="section-title">Map Families</div>
          <div class="preset-grid">
            <button class="preset-btn" data-preset="corridors" data-width="4">
              Corridors (W=4)
            </button>
            <button class="preset-btn" data-preset="corridors" data-width="2">
              Corridors (W=2)
            </button>
            <button class="preset-btn" data-preset="rooms_doors">
              Rooms & Doors
            </button>
            <button class="preset-btn" data-preset="mazes">
              Mazes + Dead-ends
            </button>
            <button class="preset-btn" data-preset="random_obstacles" data-density="0.2">
              Random (20%)
            </button>
            <button class="preset-btn" data-preset="random_obstacles" data-density="0.4">
              Random (40%)
            </button>
          </div>
        </div>
        
        <div class="control-section">
          <div class="section-title">RL Training</div>
          <div class="param-group">
            <div class="param-header">
              <span class="param-label" title="Mixture ratio: β=1 (pure BICEP demos), β=0 (pure RL policy). Anneals during training.">Demo ratio β</span>
              <span class="param-value" id="beta-value">0.5</span>
            </div>
            <input type="range" class="param-slider" id="beta" min="0" max="1" value="0.5" step="0.1">
            <div class="param-info">Mix: (1-β)·π_RL + β·π_BICEP</div>
          </div>
          
          <div class="param-group">
            <div class="param-header">
              <span class="param-label">Episodes</span>
              <span class="param-value" id="episodes-value">100</span>
            </div>
            <input type="range" class="param-slider" id="episodes" min="50" max="500" value="100" step="25">
            <div class="param-info">Training episodes per phase</div>
          </div>
          
          <div class="checkbox-group" style="margin-bottom: 0.75rem;">
            <input type="checkbox" id="buffer-training">
            <label for="buffer-training" title="Use experience replay buffer instead of pure on-policy learning">Buffer-based training</label>
          </div>
          
          <div class="action-buttons">
            <button id="train-btn">Train Agent</button>
            <button id="eval-btn" class="secondary">Evaluate</button>
          </div>
          
          <div class="action-buttons" style="margin-top: 0.5rem;">
            <button id="export-png" class="secondary">Export PNG</button>
            <button id="export-csv" class="secondary">Export CSV</button>
          </div>
        </div>
      </div>
    </div>

    <div class="info-grid">
      <div class="info-panel">
        <div class="info-title">What BICEP Does</div>
        <div class="info-item">• Spawns <strong>K trajectories</strong> in parallel (not sequential)</div>
        <div class="info-item">• Each follows <strong>Brownian bridge</strong> dynamics:</div>
        <div class="formula">x_{t+Δt} = x_t + μ·(goal-x_t)/(1-t)·Δt + σ·√Δt·Z_t</div>
        <div class="info-item">• <strong>Deterministic</strong>: same seed → identical replay</div>
        <div class="info-item">• <strong>Streaming</strong>: processes in batches to scale</div>
        <div class="info-item">Legend: <span style="color: #22c55e;">█</span> start, <span style="color: #3b82f6;">█</span> goal, <span style="color: #dc2626;">█</span> obstacles</div>
      </div>
      
      <div class="info-panel">
        <div class="info-title">Success Criteria & Cost</div>
        <div class="info-item"><strong>Success:</strong> Reach any <span style="color: #3b82f6;">█</span> goal cell within T steps</div>
        <div class="info-item"><strong>Cost:</strong> Path length + 0.1×obstacle proximity</div>
        <div class="info-item"><strong>Ranking:</strong> Lower cost = better path</div>
        <div class="info-item"><strong>Note:</strong> This is a sampler, not A* (shortest path)</div>
      </div>
      
      <div class="info-panel">
        <div class="info-title">RL Training Status</div>
        <div class="info-item" id="training-status">• <strong>Demo Buffer:</strong> <span id="demo-count">0</span> trajectories</div>
        <div class="info-item" id="rl-buffer-status">• <strong>RL Buffer:</strong> <span id="rl-buffer-count">0</span> episodes</div>
        <div class="info-item" id="mixture-status">• <strong>Current β:</strong> <span id="beta-display">0.5</span> (demo ratio)</div>
        <div class="info-item" id="phase-status">• <strong>Phase:</strong> <span id="current-phase">Initialization</span></div>
      </div>
      
      <div class="info-panel">
        <div class="info-title">Why BICEP vs A*</div>
        <div class="info-item">• Handles <strong>uncertainty</strong> & stochastic environments</div>
        <div class="info-item">• Finds <strong>distribution</strong> of paths, not just one</div>
        <div class="info-item">• <strong>GPU-ready</strong>: embarrassingly parallel</div>
        <div class="info-item">• <strong>Risk-aware</strong>: rank by CVaR, not just mean</div>
      </div>
    </div>
  </div>

  <script>
    // Deterministic RNG - single source for all randomness (MUST BE FIRST)
    class DeterministicRNG {
      constructor(seed) {
        this.state = seed;
        this.originalSeed = seed;
      }
      
      next() {
        this.state = (this.state * 1664525 + 1013904223) % 4294967296;
        return this.state / 4294967296;
      }
      
      // Gaussian random (Box-Muller)
      gaussian() {
        const u1 = Math.max(this.next(), 1e-12);
        const u2 = this.next();
        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      }
      
      // Integer in range [min, max)
      int(min, max) {
        return Math.floor(this.next() * (max - min)) + min;
      }
      
      // Reset to original seed
      reset() {
        this.state = this.originalSeed;
      }
    }
    
    // Global RNG instance
    let globalRNG = new DeterministicRNG(Math.floor(Math.random() * 1000000));
    
    // Canvas setup
    const bgCanvas = document.getElementById('bg-canvas');
    const obsCanvas = document.getElementById('obs-canvas');
    const simCanvas = document.getElementById('sim-canvas');
    const pathCanvas = document.getElementById('path-canvas');
    const sparklineCanvas = document.getElementById('sparkline-canvas');
    const costHistogram = document.getElementById('cost-histogram');
    
    const bgCtx = bgCanvas.getContext('2d');
    const obsCtx = obsCanvas.getContext('2d');
    const simCtx = simCanvas.getContext('2d');
    const pathCtx = pathCanvas.getContext('2d');
    const sparkCtx = sparklineCanvas.getContext('2d');
    const histCtx = costHistogram.getContext('2d');
    
    // Grid settings
    const gridSize = 40;
    const cellSize = 13;
    let grid = [];
    let particles = [];
    let winners = [];
    let heatmap = new Float32Array(gridSize * gridSize);
    let mode = 'particles';
    let running = false;
    let step = 0;
    let horizon = 300;
    let currentSeed = globalRNG.originalSeed;
    let currentMapSeed = globalRNG.int(0, 1000000);
    let rng = globalRNG;
    
    // Performance tracking
    let frameStart = 0;
    let frameTime = 0;
    let throughput = 0;
    let throughputHistory = [];
    let successHistory = [];
    let currentBatch = 0;
    let totalBatches = 1;
    let reachedParticleIds = new Set();
    let collisionCount = 0;
    let stalledCount = 0;
    
    // Start and goal regions
    const startCells = [];
    const goalCells = [];
    
    // Map factory & RL state
    let currentMapFamily = 'corridors';
    let mapParams = { width: 4, density: 0.2 };
    let rlAgent = null;
    let trainingRunning = false;
    let demoBuffer = [];
    let rlBuffer = [];
    let currentPhase = 0;
    let rlStats = {
      episode: 0,
      totalEpisodes: 100,
      reward: 0,
      successRate: 0,
      avgSteps: 0,
      recentRewards: []
    };
    
    // RNG class moved to top of script
    
    // Legacy function - now uses global RNG
    function gaussianRandom() {
      return globalRNG.gaussian();
    }
    
    // Path validation using BFS
    function hasValidPath(grid, starts, goals) {
      const visited = new Set();
      const queue = [...starts];
      
      for (const [x, y] of starts) {
        visited.add(`${x},${y}`);
      }
      
      while (queue.length > 0) {
        const [x, y] = queue.shift();
        
        // Check if we reached a goal
        for (const [gx, gy] of goals) {
          if (Math.abs(x - gx) < 1.5 && Math.abs(y - gy) < 1.5) {
            return true;
          }
        }
        
        // Explore neighbors
        for (const [dx, dy] of [[-1,0], [1,0], [0,-1], [0,1]]) {
          const nx = x + dx;
          const ny = y + dy;
          const key = `${nx},${ny}`;
          
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && 
              !grid[nx][ny] && !visited.has(key)) {
            visited.add(key);
            queue.push([nx, ny]);
          }
        }
      }
      
      return false;
    }
    
    // Map Factory - Generate different environment types with validation
    function generateMap(family, params, mapSeed) {
      const mapRng = new DeterministicRNG(mapSeed);
      let attempts = 0;
      const maxAttempts = 10;
      
      while (attempts < maxAttempts) {
        let newGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
        
        switch(family) {
          case 'corridors':
            newGrid = generateCorridor(newGrid, params.width || 4, mapRng);
            break;
          case 'rooms_doors':
            newGrid = generateRoomsDoors(newGrid, mapRng);
            break;
          case 'mazes':
            newGrid = generateMaze(newGrid, mapRng);
            break;
          case 'random_obstacles':
            newGrid = generateRandomObstacles(newGrid, params.density || 0.2, mapRng);
            break;
          default:
            newGrid = generateCorridor(newGrid, 4, mapRng);
        }
        
        // Validate path exists using current start/goal positions
        const testStarts = [[3, 20], [3, 19]]; // Default start region
        const testGoals = [[36, 20], [36, 19]]; // Default goal region
        
        if (hasValidPath(newGrid, testStarts, testGoals)) {
          return newGrid;
        }
        
        attempts++;
        // Reduce obstacle density for retry
        if (params.density) params.density *= 0.8;
        if (params.width) params.width = Math.max(params.width + 1, 6);
      }
      
      // Fallback: return simple corridor if all attempts fail
      let fallbackGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
      return generateCorridor(fallbackGrid, 6, mapRng);
    }
    
    function generateCorridor(newGrid, width, rng) {
      // Create corridor with specified width
      const corridorY = Math.floor(gridSize / 2);
      const halfWidth = Math.floor(width / 2);
      
      // Block top and bottom
      for (let x = 3; x < gridSize - 3; x++) {
        for (let y = 0; y < corridorY - halfWidth; y++) {
          newGrid[x][y] = true;
        }
        for (let y = corridorY + halfWidth + 1; y < gridSize; y++) {
          newGrid[x][y] = true;
        }
      }
      
      // Add some random obstacles in corridor
      const numObs = rng.int(0, width);
      for (let i = 0; i < numObs; i++) {
        const x = 5 + rng.int(0, gridSize - 10);
        const y = corridorY - halfWidth + rng.int(0, width);
        if (y >= 0 && y < gridSize) newGrid[x][y] = true;
      }
      
      return newGrid;
    }
    
    function generateRoomsDoors(newGrid, rng) {
      // Create 3 connected rooms with some randomness
      const baseRooms = [
        {x: 5, y: 5, w: 8, h: 8},
        {x: 20, y: 8, w: 10, h: 6},
        {x: 15, y: 25, w: 12, h: 8}
      ];
      
      // Add slight random variation to room positions
      const rooms = baseRooms.map(room => ({
        x: room.x + rng.int(-2, 3),
        y: room.y + rng.int(-2, 3),
        w: room.w + rng.int(-1, 2),
        h: room.h + rng.int(-1, 2)
      }));
      
      // Fill everything first
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          newGrid[x][y] = true;
        }
      }
      
      // Clear rooms
      rooms.forEach(room => {
        for (let x = room.x; x < room.x + room.w; x++) {
          for (let y = room.y; y < room.y + room.h; y++) {
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
              newGrid[x][y] = false;
            }
          }
        }
      });
      
      // Add doors between rooms with some variation
      for (let x = 13; x < 20; x++) {
        if (rng.next() > 0.2) {
          newGrid[x][10] = false;
          newGrid[x][11] = false;
        }
      }
      
      for (let y = 14; y < 25; y++) {
        if (rng.next() > 0.2) {
          newGrid[22][y] = false;
          newGrid[23][y] = false;
        }
      }
      
      return newGrid;
    }
    
    function generateMaze(newGrid, rng) {
      // Simple maze generation with dead ends
      for (let i = 0; i < 12; i++) {
        const x = 5 + i * 3;
        for (let y = 0; y < gridSize; y++) {
          if (rng.next() > 0.3) newGrid[x][y] = true;
        }
      }
      
      // Add horizontal barriers to create dead ends
      for (let y = 8; y < gridSize - 8; y += 6) {
        for (let x = 6; x < gridSize - 6; x++) {
          if (rng.next() > 0.4) newGrid[x][y] = true;
        }
      }
      
      return newGrid;
    }
    
    function generateRandomObstacles(newGrid, density, rng) {
      const numObstacles = Math.floor(gridSize * gridSize * density);
      for (let i = 0; i < numObstacles; i++) {
        const x = 3 + rng.int(0, gridSize - 6);
        const y = rng.int(0, gridSize);
        newGrid[x][y] = true;
      }
      
      return newGrid;
    }
    
    // Simple RL Agent (Q-learning)
    class QLearningAgent {
      constructor(gridSize, learningRate = 0.1, epsilon = 0.1, discount = 0.95) {
        this.gridSize = gridSize;
        this.learningRate = learningRate;
        this.epsilon = epsilon;
        this.discount = discount;
        this.qTable = new Map();
        this.actions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up
      }
      
      stateKey(x, y) {
        return `${Math.floor(x)},${Math.floor(y)}`;
      }
      
      getQValue(state, action) {
        const key = `${state}_${action}`;
        return this.qTable.get(key) || 0;
      }
      
      setQValue(state, action, value) {
        const key = `${state}_${action}`;
        this.qTable.set(key, value);
      }
      
      selectAction(x, y, epsilon = null) {
        const state = this.stateKey(x, y);
        const eps = epsilon !== null ? epsilon : this.epsilon;
        
        if (globalRNG.next() < eps) {
          return Math.floor(globalRNG.next() * this.actions.length);
        }
        
        let bestAction = 0;
        let bestValue = this.getQValue(state, 0);
        
        for (let a = 1; a < this.actions.length; a++) {
          const value = this.getQValue(state, a);
          if (value > bestValue) {
            bestValue = value;
            bestAction = a;
          }
        }
        
        return bestAction;
      }
      
      update(state, action, reward, nextState) {
        const currentQ = this.getQValue(state, action);
        
        let maxNextQ = 0;
        for (let a = 0; a < this.actions.length; a++) {
          maxNextQ = Math.max(maxNextQ, this.getQValue(nextState, a));
        }
        
        const newQ = currentQ + this.learningRate * (reward + this.discount * maxNextQ - currentQ);
        this.setQValue(state, action, newQ);
      }
      
      // Warm start with BICEP demos
      initFromDemos(demos) {
        demos.forEach(demo => {
          const path = demo.path;
          for (let i = 0; i < path.length - 1; i++) {
            const curr = path[i];
            const next = path[i + 1];
            const state = this.stateKey(curr[0], curr[1]);
            
            // Find action that moves from curr to next
            for (let a = 0; a < this.actions.length; a++) {
              const [dx, dy] = this.actions[a];
              if (curr[0] + dx === next[0] && curr[1] + dy === next[1]) {
                // Initialize with small positive value
                const currentQ = this.getQValue(state, a);
                this.setQValue(state, a, Math.max(currentQ, 0.1));
                break;
              }
            }
          }
        });
      }
    }
    
    // RL Environment
    class GridEnvironment {
      constructor(grid, startCells, goalCells) {
        this.grid = grid;
        this.startCells = startCells;
        this.goalCells = goalCells;
        this.reset();
      }
      
      reset() {
        const start = this.startCells[globalRNG.int(0, this.startCells.length)];
        this.agentX = start[0] + 0.5;
        this.agentY = start[1] + 0.5;
        this.steps = 0;
        this.done = false;
        return { x: this.agentX, y: this.agentY };
      }
      
      step(action) {
        if (this.done) return { state: {x: this.agentX, y: this.agentY}, reward: 0, done: true };
        
        const [dx, dy] = [[0, 1], [1, 0], [0, -1], [-1, 0]][action];
        const newX = Math.max(0, Math.min(gridSize - 1, this.agentX + dx));
        const newY = Math.max(0, Math.min(gridSize - 1, this.agentY + dy));
        
        let reward = -0.01; // Step penalty
        
        // Check collision
        if (this.grid[Math.floor(newX)][Math.floor(newY)]) {
          reward = -0.1; // Collision penalty
        } else {
          this.agentX = newX;
          this.agentY = newY;
        }
        
        // Check goal
        const gridX = Math.floor(this.agentX);
        const gridY = Math.floor(this.agentY);
        if (this.goalCells.some(g => g[0] === gridX && g[1] === gridY)) {
          reward = 1.0; // Goal reward
          this.done = true;
        }
        
        this.steps++;
        if (this.steps >= horizon) {
          this.done = true;
        }
        
        return {
          state: { x: this.agentX, y: this.agentY },
          reward: reward,
          done: this.done
        };
      }
    }
    
    // Demo service API
    function generateDemos(envKey, want, K, horizonSteps, sigma, drift, seed) {
      // Use current BICEP implementation
      currentSeed = seed;
      globalRNG = new DeterministicRNG(seed);  // Reseed globalRNG for reproducibility
      winners = [];
      heatmap.fill(0);
      step = 0;
      successHistory = [];
      currentBatch = 0;
      horizon = horizonSteps;
      
      // Set parameters
      document.getElementById('particles').value = K;
      document.getElementById('sigma').value = sigma;
      document.getElementById('drift').value = drift;
      document.getElementById('horizon-slider').value = horizonSteps;
      
      // Update displays
      document.getElementById('particles-value').textContent = K;
      document.getElementById('sigma-value').textContent = sigma;
      document.getElementById('drift-value').textContent = drift;
      document.getElementById('horizon-value').textContent = horizonSteps;
      
      return new Promise((resolve) => {
        // Run BICEP sampling
        initParticles();
        
        function runToCompletion() {
          updateParticles();
          drawSimulation();
          drawBestPath();
          drawSparkline();
          drawCostHistogram();
          updateStats();
          
          const active = particles.filter(p => p.alive && !p.reached).length;
          if (active === 0 || step >= horizon) {
            const demos = winners.slice(0, want).map(w => ({
              path: w.path,
              cost: w.cost
            }));
            
            const stats = {
              successRate: particles.length > 0 ? winners.length / particles.length : 0,
              avgCost: winners.length > 0 ? winners.reduce((s, w) => s + w.cost, 0) / winners.length : 0,
              throughput: throughput
            };
            
            resolve({ demos, stats });
          } else {
            requestAnimationFrame(runToCompletion);
          }
        }
        
        runToCompletion();
      });
    }
    
    // Initialize canvases
    function initCanvases() {
      const width = gridSize * cellSize;
      const height = gridSize * cellSize;
      
      [bgCanvas, obsCanvas, simCanvas, pathCanvas].forEach(canvas => {
        canvas.width = width;
        canvas.height = height;
      });
      
      sparklineCanvas.width = 180;
      sparklineCanvas.height = 40;
      
      costHistogram.width = 230;
      costHistogram.height = 60;
      
      // Draw background grid
      bgCtx.fillStyle = '#0a0a0a';
      bgCtx.fillRect(0, 0, width, height);
      
      bgCtx.strokeStyle = 'rgba(255,255,255,0.02)';
      bgCtx.lineWidth = 1;
      for (let i = 0; i <= gridSize; i++) {
        bgCtx.beginPath();
        bgCtx.moveTo(i * cellSize, 0);
        bgCtx.lineTo(i * cellSize, height);
        bgCtx.stroke();
        
        bgCtx.beginPath();
        bgCtx.moveTo(0, i * cellSize);
        bgCtx.lineTo(width, i * cellSize);
        bgCtx.stroke();
      }
    }
    
    function initGrid() {
      grid = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
      
      // Define start and goal regions
      startCells.length = 0;
      goalCells.length = 0;
      
      // Start: left side green band
      for (let y = 10; y < 30; y++) {
        for (let x = 0; x < 3; x++) {
          startCells.push([x, y]);
        }
      }
      
      // Goal: right side blue band
      for (let y = 10; y < 30; y++) {
        for (let x = gridSize - 3; x < gridSize; x++) {
          goalCells.push([x, y]);
        }
      }
      
      // Add deterministic default obstacles using globalRNG
      for (let i = 0; i < 100; i++) {
        const x = 5 + globalRNG.int(0, gridSize - 10);
        const y = globalRNG.int(0, gridSize);
        grid[x][y] = true;
      }
      
      particles = [];
      winners = [];
      heatmap.fill(0);
      step = 0;
      successHistory = [];
      
      drawObstacles();
    }
    
    function drawObstacles() {
      obsCtx.clearRect(0, 0, obsCanvas.width, obsCanvas.height);
      
      // Start region - green
      obsCtx.fillStyle = 'rgba(34, 197, 94, 0.2)';
      startCells.forEach(([x, y]) => {
        obsCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      });
      
      // Goal region - blue  
      obsCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
      goalCells.forEach(([x, y]) => {
        obsCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      });
      
      // Obstacles - red (colorblind friendly)
      obsCtx.fillStyle = 'rgba(220, 38, 38, 0.7)';
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          if (grid[x][y]) {
            obsCtx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);
          }
        }
      }
    }
    
    function initParticles() {
      const numParticles = parseInt(document.getElementById('particles').value);
      const batchSize = parseInt(document.getElementById('batch-size').value);
      
      particles = [];
      winners = [];
      reachedParticleIds.clear();
      collisionCount = 0;
      rng = new DeterministicRNG(currentSeed);
      
      // Calculate batches for streaming
      totalBatches = Math.ceil(numParticles / batchSize);
      currentBatch = 0;
      
      // Initialize all particles with per-particle time tracking
      for (let i = 0; i < numParticles; i++) {
        const start = startCells[rng.int(0, startCells.length)];
        particles.push({
          id: i,
          x: start[0] + 0.5,
          y: start[1] + 0.5,
          path: [[start[0], start[1]]],
          alive: true,
          cost: 0,
          time: 0.0,  // Start at t=0 in [0,1] normalized time
          batch: Math.floor(i / batchSize),
          reached: false
        });
      }
      
      // Show batch progress
      if (totalBatches > 1) {
        document.getElementById('batch-progress').classList.add('show');
        document.getElementById('total-batches').textContent = totalBatches;
      }
    }
    
    function updateParticles() {
      frameStart = performance.now();
      
      const sigma = parseFloat(document.getElementById('sigma').value);
      const drift = parseFloat(document.getElementById('drift').value);
      const correlation = parseFloat(document.getElementById('correlation').value);
      const antithetic = document.getElementById('antithetic').checked;
      const windAngle = parseFloat(document.getElementById('wind-angle').value) * Math.PI / 180;
      const windStrength = parseFloat(document.getElementById('wind-strength').value);
      const batchSize = parseInt(document.getElementById('batch-size').value);
      
      const windX = Math.cos(windAngle) * windStrength;
      const windY = Math.sin(windAngle) * windStrength;
      
      // Correct Δt semantics: Δt = 1/T
      const dt = 1.0 / horizon;
      const sqrtDt = Math.sqrt(dt);
      
      let activeCount = 0;
      let processedCount = 0;
      
      // Proper streaming: advance all particles by one step, batch by batch
      for (let batch = 0; batch < totalBatches; batch++) {
        document.getElementById('current-batch').textContent = batch + 1;
        const batchStart = batch * batchSize;
        const batchEnd = Math.min(batchStart + batchSize, particles.length);
        
        for (let idx = batchStart; idx < batchEnd; idx++) {
          const p = particles[idx];
          if (!p.alive || p.reached) continue;
          
          activeCount++;
          processedCount++;
          
          // Per-particle time tracking in [0,1] normalized domain
          const normalizedTime = p.time; // Already in [0,1] since we accumulate dt=1/T
          const remaining = Math.max(dt, 1.0 - normalizedTime);
          
          // Find nearest goal
          let minDist = Infinity;
          let nearestGoal = goalCells[0];
          goalCells.forEach(g => {
            const dist = Math.sqrt((g[0] - p.x) ** 2 + (g[1] - p.y) ** 2);
            if (dist < minDist) {
              minDist = dist;
              nearestGoal = g;
            }
          });
          
          // Brownian bridge dynamics: CONSISTENT [0,1] time domain
          // Drift term: μ·(goal-x)/(1-t)·Δt where both t,Δt ∈ [0,1]
          const pullX = drift * (nearestGoal[0] + 0.5 - p.x) / remaining * dt;
          const pullY = drift * (nearestGoal[1] + 0.5 - p.y) / remaining * dt;
          
          // Correlated noise: σ·√Δt·Z with correlation ρ
          let noiseX, noiseY;
          if (antithetic && (p.id % 2) === 1) {
            // Find antithetic twin by XOR with 1
            const twinId = p.id ^ 1;
            const twin = particles[twinId];
            if (twin && twin.lastNoise) {
              noiseX = -twin.lastNoise.x + windX;
              noiseY = -twin.lastNoise.y + windY;
            } else {
              const z1 = globalRNG.gaussian();
              const z2 = globalRNG.gaussian();
              noiseX = z1 * sigma * sqrtDt + windX;
              noiseY = (correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2) * sigma * sqrtDt + windY;
              p.lastNoise = { x: z1 * sigma * sqrtDt, y: (correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2) * sigma * sqrtDt };
            }
          } else {
            const z1 = globalRNG.gaussian();
            const z2 = globalRNG.gaussian();
            // Apply correlation: Y = ρX + √(1-ρ²)Z
            noiseX = z1 * sigma * sqrtDt + windX;
            noiseY = (correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2) * sigma * sqrtDt + windY;
            p.lastNoise = { x: z1 * sigma * sqrtDt, y: (correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2) * sigma * sqrtDt };
          }
          
          // Update position and time
          p.x += pullX + noiseX;
          p.y += pullY + noiseY;
          p.time += dt; // Increment in [0,1] domain
          
          // Bounds check
          p.x = Math.max(0, Math.min(gridSize - 1, p.x));
          p.y = Math.max(0, Math.min(gridSize - 1, p.y));
          
          const gridX = Math.floor(p.x);
          const gridY = Math.floor(p.y);
          
          // Update heatmap
          heatmap[gridY * gridSize + gridX] += 1;
          
          // Check collision
          if (grid[gridX][gridY]) {
            p.alive = false;
            collisionCount++;
          } else {
            p.path.push([gridX, gridY]);
            
            // Cost with obstacle proximity
            let proxPenalty = 0;
            for (let dx = -1; dx <= 1; dx++) {
              for (let dy = -1; dy <= 1; dy++) {
                const nx = gridX + dx;
                const ny = gridY + dy;
                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[nx][ny]) {
                  proxPenalty += 0.1;
                }
              }
            }
            p.cost += 1.0 + proxPenalty; // Cost in interpretable step units
            
            // Check goal
            if (goalCells.some(g => g[0] === gridX && g[1] === gridY)) {
              p.reached = true;
              reachedParticleIds.add(p.id);
              recordWinner(p);
            }
          }
        }
      }
      
      // Calculate stable throughput with rolling average
      const frameEnd = performance.now();
      frameTime = frameEnd - frameStart;
      const instantThroughput = Math.round(processedCount * (1000 / Math.max(frameTime, 1)));
      throughputHistory.push(instantThroughput);
      if (throughputHistory.length > 10) throughputHistory.shift();
      throughput = Math.round(throughputHistory.reduce((a, b) => a + b, 0) / throughputHistory.length);
      
      // Update success history with accurate count
      const accurateSuccessRate = particles.length > 0 ? (reachedParticleIds.size / particles.length * 100) : 0;
      successHistory.push(accurateSuccessRate);
      if (successHistory.length > 100) successHistory.shift();
      
      step++;
    }
    
    // CVaR surrogate via clearance-based risk assessment
    function calculatePathRisk(path) {
      let totalRisk = 0;
      let minClearance = Infinity;
      
      for (const [x, y] of path) {
        // Calculate minimum clearance to obstacles
        let localClearance = Infinity;
        for (let dx = -3; dx <= 3; dx++) {
          for (let dy = -3; dy <= 3; dy++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[nx][ny]) {
              const clearance = Math.sqrt(dx*dx + dy*dy);
              localClearance = Math.min(localClearance, clearance);
            }
          }
        }
        
        minClearance = Math.min(minClearance, localClearance);
        
        // Risk penalty: exponential in low clearance  
        if (localClearance < 2.5) {
          totalRisk += Math.exp(2.5 - localClearance) * 0.1;
        }
      }
      
      return {
        clearanceRisk: totalRisk,
        minClearance: minClearance,
        riskScore: totalRisk + (minClearance < 1.5 ? 2.0 : 0)
      };
    }
    
    function recordWinner(particle) {
      const useCVar = document.getElementById('cvar-toggle').checked;
      
      // Calculate path risk using clearance-based surrogate
      const riskMetrics = calculatePathRisk(particle.path);
      
      winners.push({
        path: particle.path.slice(),
        cost: particle.cost,
        risk: riskMetrics.riskScore,
        clearance: riskMetrics.minClearance,
        id: particle.id
      });
      
      // Sort by cost or risk depending on CVaR toggle
      if (useCVar) {
        winners.sort((a, b) => a.risk - b.risk); // Ascending by risk (safer is better)
      } else {
        winners.sort((a, b) => a.cost - b.cost); // Ascending by cost
      }
      
      // Keep top 50
      if (winners.length > 50) winners.length = 50;
    }
    
    function drawSimulation() {
      simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
      
      if (mode === 'particles') {
        // Fade effect for trails
        simCtx.fillStyle = 'rgba(0,0,0,0.05)';
        simCtx.fillRect(0, 0, simCanvas.width, simCanvas.height);
        
        // Draw all active particles
        simCtx.fillStyle = 'rgba(59,130,246,0.8)';
        particles.forEach(p => {
          if (p.alive && !p.reached) {
            simCtx.fillRect(p.x * cellSize - 1, p.y * cellSize - 1, 2, 2);
          }
        });
      } else if (mode === 'heatmap') {
        const maxHeat = Math.max(...heatmap);
        if (maxHeat > 0) {
          for (let i = 0; i < heatmap.length; i++) {
            if (heatmap[i] > 0) {
              const x = i % gridSize;
              const y = Math.floor(i / gridSize);
              const intensity = Math.pow(heatmap[i] / maxHeat, 0.5);
              simCtx.fillStyle = `rgba(59,130,246,${0.1 + 0.6 * intensity})`;
              simCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
      } else if (mode === 'paths') {
        // Draw top N paths
        simCtx.lineWidth = 1.5;
        simCtx.lineCap = 'round';
        
        winners.slice(1, 30).forEach((w, i) => {
          const hue = 200 + (i * 5) % 60;
          simCtx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.3)`;
          simCtx.beginPath();
          w.path.forEach((pos, j) => {
            const x = pos[0] * cellSize + cellSize / 2;
            const y = pos[1] * cellSize + cellSize / 2;
            if (j === 0) simCtx.moveTo(x, y);
            else simCtx.lineTo(x, y);
          });
          simCtx.stroke();
        });
      }
    }
    
    function drawBestPath() {
      pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
      
      if (winners.length === 0) return;
      
      const best = winners[0].path;
      
      // Draw with glow
      pathCtx.shadowColor = 'rgba(16,185,129,0.6)';
      pathCtx.shadowBlur = 12;
      pathCtx.strokeStyle = '#10b981';
      pathCtx.lineWidth = 3;
      pathCtx.lineCap = 'round';
      pathCtx.lineJoin = 'round';
      
      pathCtx.beginPath();
      best.forEach((pos, i) => {
        const x = pos[0] * cellSize + cellSize / 2;
        const y = pos[1] * cellSize + cellSize / 2;
        if (i === 0) pathCtx.moveTo(x, y);
        else pathCtx.lineTo(x, y);
      });
      pathCtx.stroke();
      
      // Arrowheads
      pathCtx.shadowBlur = 0;
      pathCtx.fillStyle = '#10b981';
      for (let i = 10; i < best.length; i += 10) {
        if (i < 1) continue;
        const curr = best[i];
        const prev = best[i - 1];
        const x = curr[0] * cellSize + cellSize / 2;
        const y = curr[1] * cellSize + cellSize / 2;
        const px = prev[0] * cellSize + cellSize / 2;
        const py = prev[1] * cellSize + cellSize / 2;
        
        const angle = Math.atan2(y - py, x - px);
        
        pathCtx.save();
        pathCtx.translate(x, y);
        pathCtx.rotate(angle);
        pathCtx.beginPath();
        pathCtx.moveTo(0, 0);
        pathCtx.lineTo(-8, 4);
        pathCtx.lineTo(-8, -4);
        pathCtx.closePath();
        pathCtx.fill();
        pathCtx.restore();
      }
    }
    
    function drawSparkline() {
      sparkCtx.clearRect(0, 0, sparklineCanvas.width, sparklineCanvas.height);
      
      if (successHistory.length < 2) return;
      
      const w = sparklineCanvas.width;
      const h = sparklineCanvas.height;
      const max = Math.max(100, Math.max(...successHistory));
      
      sparkCtx.strokeStyle = '#10b981';
      sparkCtx.lineWidth = 2;
      sparkCtx.beginPath();
      
      successHistory.forEach((rate, i) => {
        const x = (i / (successHistory.length - 1)) * w;
        const y = h - (rate / max) * h;
        if (i === 0) sparkCtx.moveTo(x, y);
        else sparkCtx.lineTo(x, y);
      });
      
      sparkCtx.stroke();
      
      // Fill
      sparkCtx.globalAlpha = 0.2;
      sparkCtx.fillStyle = '#10b981';
      sparkCtx.lineTo(w, h);
      sparkCtx.lineTo(0, h);
      sparkCtx.closePath();
      sparkCtx.fill();
      sparkCtx.globalAlpha = 1;
    }
    
    function drawCostHistogram() {
      histCtx.clearRect(0, 0, costHistogram.width, costHistogram.height);
      
      if (winners.length < 3) return;
      
      const costs = winners.slice(0, 20).map(w => w.cost);
      const minCost = Math.min(...costs);
      const maxCost = Math.max(...costs);
      const range = maxCost - minCost;
      
      if (range === 0) return;
      
      const bins = 12;
      const binSize = range / bins;
      const histogram = new Array(bins).fill(0);
      
      costs.forEach(cost => {
        const binIndex = Math.min(bins - 1, Math.floor((cost - minCost) / binSize));
        histogram[binIndex]++;
      });
      
      const w = costHistogram.width;
      const h = costHistogram.height;
      const barWidth = w / bins;
      const maxCount = Math.max(...histogram);
      
      histogram.forEach((count, i) => {
        const barHeight = (count / maxCount) * h * 0.8;
        const x = i * barWidth;
        const y = h - barHeight;
        
        histCtx.fillStyle = '#3b82f6';
        histCtx.fillRect(x + 1, y, barWidth - 2, barHeight);
      });
      
      // Labels
      histCtx.fillStyle = '#6b7280';
      histCtx.font = '8px Inter';
      histCtx.fillText(minCost.toFixed(1), 2, h - 2);
      histCtx.fillText(maxCost.toFixed(1), w - 20, h - 2);
    }
    
    function updateStats() {
      const active = particles.filter(p => p.alive && !p.reached).length;
      const total = particles.length;
      const successRate = total > 0 ? Math.round(reachedParticleIds.size / total * 100) : 0;
      
      document.getElementById('seed-value').textContent = currentSeed;
      document.getElementById('map-seed-value').textContent = currentMapSeed;
      document.getElementById('throughput').textContent = throughput.toLocaleString();
      document.getElementById('frame-time').textContent = Math.round(frameTime);
      document.getElementById('active-count').textContent = active.toLocaleString();
      document.getElementById('total-count').textContent = total.toLocaleString();
      document.getElementById('success-rate').textContent = successRate + '%';
      document.getElementById('collision-count').textContent = collisionCount;
      document.getElementById('stalled-count').textContent = stalledCount;
      document.getElementById('step-counter').textContent = step;
      document.getElementById('horizon').textContent = horizon;
    }
    
    function animateFinish() {
      if (winners.length === 0) return;
      
      const best = winners[0].path;
      let glowStep = 0;
      
      function glowFrame() {
        pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
        drawBestPath();
        
        // Traveling glow
        const progress = (glowStep % 40) / 40;
        const idx = Math.floor(progress * best.length);
        
        if (idx < best.length) {
          const pos = best[idx];
          const x = pos[0] * cellSize + cellSize / 2;
          const y = pos[1] * cellSize + cellSize / 2;
          
          pathCtx.save();
          pathCtx.globalCompositeOperation = 'screen';
          pathCtx.fillStyle = 'rgba(16,185,129,0.8)';
          pathCtx.beginPath();
          pathCtx.arc(x, y, 10, 0, Math.PI * 2);
          pathCtx.fill();
          pathCtx.restore();
        }
        
        glowStep++;
        if (glowStep < 80) requestAnimationFrame(glowFrame);
      }
      
      glowFrame();
    }
    
    function animate() {
      if (!running) return;
      
      updateParticles();
      drawSimulation();
      drawBestPath();
      drawSparkline();
      drawCostHistogram();
      updateStats();
      
      // Check finish - count stalled particles  
      const active = particles.filter(p => p.alive && !p.reached).length;
      stalledCount = particles.filter(p => p.alive && !p.reached && p.time >= 0.95).length;
      
      // Stop when particles reach end of time domain [0,1]
      const maxTime = particles.length > 0 ? Math.max(...particles.map(p => p.time)) : 0;
      if (active === 0 || maxTime >= 1.0) {
        running = false;
        document.getElementById('run-btn').textContent = 'Run BICEP';
        document.getElementById('run-btn').disabled = false;
        document.getElementById('batch-progress').classList.remove('show');
        
        // Show completion state
        if (winners.length > 0) {
          animateFinish();
          // Show export options after completion
          setTimeout(() => {
            document.getElementById('export-png').style.opacity = '1';
            document.getElementById('export-csv').style.opacity = '1';
          }, 1000);
        }
      } else {
        requestAnimationFrame(animate);
      }
    }
    
    // Replay functionality
    function replayFromSeed(seed, mapSeed = null) {
      if (running) return;
      
      currentSeed = seed;
      currentMapSeed = mapSeed || globalRNG.int(0, 1000000);
      globalRNG = new DeterministicRNG(currentSeed);
      
      // Regenerate map with deterministic seed
      grid = generateMap(currentMapFamily, mapParams, currentMapSeed);
      drawObstacles();
      
      winners = [];
      heatmap.fill(0);
      step = 0;
      successHistory = [];
      throughputHistory = [];
      currentBatch = 0;
      reachedParticleIds.clear();
      collisionCount = 0;
      horizon = parseInt(document.getElementById('horizon-slider').value);
      
      initParticles();
      
      running = true;
      document.getElementById('run-btn').textContent = 'Running...';
      document.getElementById('run-btn').disabled = true;
      
      animate();
    }
    
    // Event handlers
    document.getElementById('run-btn').addEventListener('click', () => {
      const newSeed = globalRNG.int(0, 1000000);
      const newMapSeed = globalRNG.int(0, 1000000);
      replayFromSeed(newSeed, newMapSeed);
    });
    
    document.getElementById('replay-btn').addEventListener('click', () => {
      const seedInput = document.getElementById('replay-seed').value;
      if (seedInput.trim()) {
        const seed = parseInt(seedInput.trim());
        if (!isNaN(seed)) {
          replayFromSeed(seed);
        }
      }
    });
    
    document.getElementById('random-seed-btn').addEventListener('click', () => {
      const newSeed = globalRNG.int(0, 1000000);
      document.getElementById('replay-seed').value = newSeed;
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      running = false;
      initGrid();
      simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
      pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
      sparkCtx.clearRect(0, 0, sparklineCanvas.width, sparklineCanvas.height);
      document.getElementById('batch-progress').classList.remove('show');
      updateStats();
    });
    
    // Mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;
        drawSimulation();
      });
    });
    
    // Seed click - copy replay URL with map seed
    document.getElementById('seed-overlay').addEventListener('click', () => {
      const url = new URL(window.location);
      url.searchParams.set('seed', currentSeed);
      url.searchParams.set('mapSeed', currentMapSeed);
      url.searchParams.set('family', currentMapFamily);
      url.searchParams.set('K', document.getElementById('particles').value);
      url.searchParams.set('mu', document.getElementById('drift').value);
      url.searchParams.set('sigma', document.getElementById('sigma').value);
      url.searchParams.set('T', document.getElementById('horizon-slider').value);
      url.searchParams.set('rho', document.getElementById('correlation').value);
      
      navigator.clipboard.writeText(url.toString()).then(() => {
        const overlay = document.getElementById('seed-overlay');
        const original = overlay.innerHTML;
        overlay.innerHTML = '<strong>Copied!</strong>';
        setTimeout(() => {
          overlay.innerHTML = original;
        }, 1000);
      });
    });
    
    // Canvas drawing
    let isDrawing = false;
    obsCanvas.addEventListener('mousedown', e => {
      isDrawing = true;
      handleDraw(e);
    });
    
    obsCanvas.addEventListener('mousemove', e => {
      if (isDrawing) handleDraw(e);
    });
    
    obsCanvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });
    
    function handleDraw(e) {
      const rect = obsCanvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / (rect.width / gridSize));
      const y = Math.floor((e.clientY - rect.top) / (rect.height / gridSize));
      
      if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
        if (!startCells.some(c => c[0] === x && c[1] === y) &&
            !goalCells.some(c => c[0] === x && c[1] === y)) {
          grid[x][y] = !grid[x][y];
          drawObstacles();
        }
      }
    }
    
    // Presets - Now using map factory
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        const density = parseFloat(btn.dataset.density) || 0.2;
        const width = parseInt(btn.dataset.width) || 4;
        
        // Update current map settings
        currentMapFamily = preset;
        mapParams = { density, width };
        
        // Generate new map with random seed
        currentMapSeed = globalRNG.int(0, 1000000);
        grid = generateMap(currentMapFamily, mapParams, currentMapSeed);
        
        drawObstacles();
      });
    });
    
    // Parameter sliders with explicit mapping
    const valueLabel = {
      particles: 'particles-value',
      drift: 'drift-value',
      sigma: 'sigma-value',
      'horizon-slider': 'horizon-value',
      correlation: 'correlation-value',
      'wind-angle': 'wind-value',
      'wind-strength': 'wind-str-value',
      'batch-size': 'batch-value',
    };

    Object.keys(valueLabel).forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('input', () => {
        const v = id === 'wind-angle' ? el.value + '°' : el.value;
        document.getElementById(valueLabel[id]).textContent = v;
      });
    });
    
    // Load from URL with full replay support
    function loadFromURL() {
      const params = new URLSearchParams(window.location.search);
      
      if (params.has('seed')) {
        currentSeed = parseInt(params.get('seed'));
        globalRNG = new DeterministicRNG(currentSeed);
      }
      
      if (params.has('mapSeed')) {
        currentMapSeed = parseInt(params.get('mapSeed'));
      }
      
      if (params.has('family')) {
        currentMapFamily = params.get('family');
      }
      
      ['K:particles', 'mu:drift', 'sigma:sigma', 'T:horizon-slider', 'rho:correlation'].forEach(pair => {
        const [param, id] = pair.split(':');
        if (params.has(param)) {
          const val = params.get(param);
          document.getElementById(id).value = val;
          document.getElementById(id).dispatchEvent(new Event('input'));
        }
      });
      
      // Regenerate map with loaded parameters if we have mapSeed
      if (params.has('mapSeed')) {
        grid = generateMap(currentMapFamily, mapParams, currentMapSeed);
        drawObstacles();
      } else if (params.has('seed')) {
        // If only main seed provided, generate deterministic map
        currentMapSeed = currentSeed + 1000; // Offset for map generation
        grid = generateMap(currentMapFamily, mapParams, currentMapSeed);
        drawObstacles();
      }
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (e.key === ' ' && !running) {
        e.preventDefault();
        document.getElementById('run-btn').click();
      } else if (e.key === 'r') {
        e.preventDefault();
        document.getElementById('reset-btn').click();
      } else if (e.key >= '1' && e.key <= '3') {
        const modes = ['particles', 'heatmap', 'paths'];
        const btn = document.querySelector(`[data-mode="${modes[parseInt(e.key) - 1]}"]`);
        if (btn) btn.click();
      }
    });
    
    // RL Training
    let rlEnvironment;
    
    async function startTraining() {
      if (trainingRunning) return;
      
      trainingRunning = true;
      document.getElementById('train-btn').textContent = 'Training...';
      document.getElementById('train-btn').disabled = true;
      document.getElementById('rl-metrics').style.display = 'block';
      
      // Initialize RL agent
      rlAgent = new QLearningAgent(gridSize);
      rlEnvironment = new GridEnvironment(grid, startCells, goalCells);
      
      // Reset stats
      rlStats.episode = 0;
      rlStats.totalEpisodes = parseInt(document.getElementById('episodes').value);
      rlStats.recentRewards = [];
      
      // Generate initial demos with BICEP
      const demos = await generateDemos('current', 20, 2000, 200, 0.6, 1.2, globalRNG.int(0, 1000000));
      rlAgent.initFromDemos(demos.demos);
      
      // Update buffer displays and track training environments
      demoBuffer = demos.demos;
      const envKey = `${currentMapFamily}_${currentMapSeed}`;
      trainedEnvKeys.add(envKey);
      document.getElementById('demo-count').textContent = demoBuffer.length;
      document.getElementById('current-phase').textContent = 'Warm-start';
      
      // Start training loop
      trainingLoop();
    }
    
    function trainingLoop() {
      if (rlStats.episode >= rlStats.totalEpisodes || !trainingRunning) {
        finishTraining();
        return;
      }
      
      // Curriculum annealing: β starts at 0.5, goes to 0
      const progress = rlStats.episode / rlStats.totalEpisodes;
      const currentBeta = Math.max(0, 0.5 * (1 - progress));
      document.getElementById('current-beta').textContent = currentBeta.toFixed(2);
      document.getElementById('beta-display').textContent = currentBeta.toFixed(2);
      
      // Update phase
      if (progress < 0.2) {
        document.getElementById('current-phase').textContent = 'Exploration (high β)';
      } else if (progress < 0.6) {
        document.getElementById('current-phase').textContent = 'Transition (mid β)';
      } else {
        document.getElementById('current-phase').textContent = 'Exploitation (low β)';
      }
      
      // Run episode
      runEpisode(currentBeta).then(() => {
        rlStats.episode++;
        
        // Update metrics
        updateRLMetrics();
        
        // Continue training
        setTimeout(trainingLoop, 50); // Small delay for UI updates
      });
    }
    
    async function runEpisode(beta) {
      const state = rlEnvironment.reset();
      let totalReward = 0;
      let steps = 0;
      
      while (!rlEnvironment.done && steps < horizon) {
        let action;
        
        // Mixture policy: (1-β)·π_RL + β·π_BICEP
        if (globalRNG.next() < beta) {
          // Use learned demo policy from BICEP trajectories
          action = getDemoPolicyAction(state.x, state.y, demoBuffer);
        } else {
          // Use RL policy
          action = rlAgent.selectAction(state.x, state.y);
        }
        
        const result = rlEnvironment.step(action);
        const stateKey = rlAgent.stateKey(state.x, state.y);
        const nextStateKey = rlAgent.stateKey(result.state.x, result.state.y);
        
        // Q-learning update with optional buffer training
        const useBuffer = document.getElementById('buffer-training').checked;
        if (useBuffer && rlBuffer.length > 10) {
          // Sample mini-batch from replay buffer
          for (let i = 0; i < 4; i++) {
            const sample = rlBuffer[Math.floor(globalRNG.next() * rlBuffer.length)];
            if (sample.finalState) {
              const sampleStateKey = rlAgent.stateKey(sample.finalState.x, sample.finalState.y);
              const sampleReward = sample.success ? 1.0 : -0.1;
              rlAgent.update(sampleStateKey, 0, sampleReward, sampleStateKey);
            }
          }
        }
        
        // Always do on-policy update
        rlAgent.update(stateKey, action, result.reward, nextStateKey);
        
        totalReward += result.reward;
        steps++;
        
        state.x = result.state.x;
        state.y = result.state.y;
      }
      
      rlStats.reward = totalReward;
      rlStats.recentRewards.push(totalReward);
      if (rlStats.recentRewards.length > 100) rlStats.recentRewards.shift();
      
      // Add to RL buffer with HER potential
      rlBuffer.push({
        episode: rlStats.episode,
        reward: totalReward,
        steps: steps,
        success: totalReward > 0.5,
        envKey: `${currentMapFamily}_${currentMapSeed}`,
        finalState: { x: state.x, y: state.y },
        // HER: treat final position as achieved goal for hindsight experience
        hindsightGoal: [Math.floor(state.x), Math.floor(state.y)]
      });
      
      // Calculate success rate from recent episodes
      const recentSuccesses = rlStats.recentRewards.filter(r => r > 0.5).length;
      rlStats.successRate = Math.round((recentSuccesses / Math.min(rlStats.recentRewards.length, 100)) * 100);
      rlStats.avgSteps = steps;
    }
    
    function updateRLMetrics() {
      document.getElementById('rl-episode').textContent = rlStats.episode;
      document.getElementById('rl-total-episodes').textContent = rlStats.totalEpisodes;
      document.getElementById('rl-reward').textContent = rlStats.reward.toFixed(2);
      document.getElementById('rl-success-rate').textContent = rlStats.successRate + '%';
      document.getElementById('rl-avg-steps').textContent = rlStats.avgSteps;
      
      // Update buffer count
      document.getElementById('rl-buffer-count').textContent = rlBuffer.length;
    }
    
    function finishTraining() {
      trainingRunning = false;
      document.getElementById('train-btn').textContent = 'Train Agent';
      document.getElementById('train-btn').disabled = false;
      document.getElementById('current-phase').textContent = 'Training Complete';
      
      // Final summary
      const finalSuccess = rlStats.successRate;
      const totalEpisodes = rlBuffer.length;
      console.log(`Training complete: ${finalSuccess}% success over ${totalEpisodes} episodes`);
    }
    
    // Fixed evaluation test suite for reproducible benchmarks
    const EVAL_SUITE = [
      {family: 'corridors', mapSeed: 12345, params: {width: 4}},
      {family: 'corridors', mapSeed: 67890, params: {width: 2}},
      {family: 'rooms_doors', mapSeed: 11111, params: {}},
      {family: 'rooms_doors', mapSeed: 22222, params: {}},
      {family: 'mazes', mapSeed: 33333, params: {}},
      {family: 'mazes', mapSeed: 44444, params: {}},
      {family: 'random_obstacles', mapSeed: 55555, params: {density: 0.2}},
      {family: 'random_obstacles', mapSeed: 66666, params: {density: 0.4}}
    ];
    
    let trainedEnvKeys = new Set(); // Track training environments for leakage detection
    
    // Demo policy: learn from BICEP demonstration waypoints
    function getDemoPolicyAction(x, y, demos) {
      if (!demos || demos.length === 0) {
        // Fallback to greedy heuristic
        const nearestGoal = goalCells.reduce((closest, g) => {
          const dist = Math.sqrt((g[0] - x) ** 2 + (g[1] - y) ** 2);
          return dist < closest.dist ? {goal: g, dist} : closest;
        }, {goal: goalCells[0], dist: Infinity});
        
        const dx = nearestGoal.goal[0] - x;
        const dy = nearestGoal.goal[1] - y;
        
        if (Math.abs(dx) > Math.abs(dy)) {
          return dx > 0 ? 0 : 2; // right or left
        } else {
          return dy > 0 ? 1 : 3; // down or up
        }
      }
      
      // Find closest waypoint in demonstrations
      let bestAction = 0;
      let minDist = Infinity;
      
      demos.forEach(demo => {
        demo.path.forEach((waypoint, i) => {
          if (i < demo.path.length - 1) {
            const dist = Math.sqrt((waypoint[0] - x) ** 2 + (waypoint[1] - y) ** 2);
            if (dist < minDist) {
              minDist = dist;
              const next = demo.path[i + 1];
              const dx = next[0] - waypoint[0];
              const dy = next[1] - waypoint[1];
              
              // Convert to action
              if (dx > 0) bestAction = 0; // right
              else if (dx < 0) bestAction = 2; // left
              else if (dy > 0) bestAction = 1; // down
              else if (dy < 0) bestAction = 3; // up
            }
          }
        });
      });
      
      return bestAction;
    }
    
    async function runEvaluation() {
      if (!rlAgent) {
        alert('Please train an agent first!');
        return;
      }
      
      document.getElementById('eval-btn').textContent = 'Evaluating...';
      document.getElementById('eval-btn').disabled = true;
      
      // Check for leakage
      const leakageCount = EVAL_SUITE.filter(test => {
        const envKey = `${test.family}_${test.mapSeed}`;
        return trainedEnvKeys.has(envKey);
      }).length;
      
      if (leakageCount > 0) {
        alert(`WARNING: ${leakageCount} eval environments were used in training (data leakage detected!)`);
      }
      
      // Run evaluation on fixed test suite
      const evalResults = [];
      const numTrials = 3; // Multiple trials per environment
      
      for (const test of EVAL_SUITE) {
        const testGrid = generateMap(test.family, test.params, test.mapSeed);
        
        // Create appropriate start/goal regions for this test grid
        const testStarts = [];
        const testGoals = [];
        
        // Start region: left side (cleared area)
        for (let y = 10; y < 30; y++) {
          for (let x = 0; x < 3; x++) {
            if (!testGrid[x][y]) {
              testStarts.push([x, y]);
            }
          }
        }
        
        // Goal region: right side (cleared area) 
        for (let y = 10; y < 30; y++) {
          for (let x = gridSize - 3; x < gridSize; x++) {
            if (!testGrid[x][y]) {
              testGoals.push([x, y]);
            }
          }
        }
        
        // Fallback if no valid start/goal found
        if (testStarts.length === 0) testStarts.push([1, 20]);
        if (testGoals.length === 0) testGoals.push([38, 20]);
        
        const testEnv = new GridEnvironment(testGrid, testStarts, testGoals);
        
        const trialResults = [];
        
        for (let trial = 0; trial < numTrials; trial++) {
          let successes = 0;
          const numEpisodes = 10;
          
          for (let i = 0; i < numEpisodes; i++) {
            let state = testEnv.reset();
            let steps = 0;
            
            while (!testEnv.done && steps < horizon) {
              const action = rlAgent.selectAction(state.x, state.y, 0.05); // Very low epsilon for evaluation
              const result = testEnv.step(action);
              
              if (result.reward > 0.5) { // Success
                successes++;
                break;
              }
              
              state = result.state; // Update state properly
              steps++;
            }
          }
          
          trialResults.push((successes / numEpisodes) * 100);
        }
        
        const mean = trialResults.reduce((a, b) => a + b, 0) / trialResults.length;
        const variance = trialResults.reduce((a, b) => a + (b - mean) ** 2, 0) / trialResults.length;
        const std = Math.sqrt(variance);
        
        evalResults.push({
          family: test.family,
          mapSeed: test.mapSeed,
          mean: mean,
          std: std
        });
      }
      
      // Display results with statistics
      const overallMean = evalResults.reduce((s, r) => s + r.mean, 0) / evalResults.length;
      const resultText = evalResults.map(r => `${r.family}:${r.mapSeed} ${r.mean.toFixed(1)}±${r.std.toFixed(1)}%`).join('\n');
      alert(`Evaluation Results (mean±std):\n${resultText}\nOverall: ${overallMean.toFixed(1)}%`);
      
      document.getElementById('eval-btn').textContent = 'Evaluate';
      document.getElementById('eval-btn').disabled = false;
    }
    
    // Export functionality
    function exportToPNG() {
      const canvas = document.createElement('canvas');
      canvas.width = bgCanvas.width;
      canvas.height = bgCanvas.height;
      const ctx = canvas.getContext('2d');
      
      // Composite all layers
      ctx.drawImage(bgCanvas, 0, 0);
      ctx.drawImage(obsCanvas, 0, 0);
      ctx.drawImage(simCanvas, 0, 0);
      ctx.drawImage(pathCanvas, 0, 0);
      
      // Add timestamp
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '12px Inter';
      ctx.fillText(`BICEP Demo - ${new Date().toISOString()} - Seed ${currentSeed}`, 10, canvas.height - 10);
      
      // Download
      const link = document.createElement('a');
      link.download = `bicep-demo-${currentSeed}-${Date.now()}.png`;
      link.href = canvas.toDataURL();
      link.click();
    }
    
    function exportToCSV() {
      if (winners.length === 0) {
        alert('No paths to export! Run BICEP first.');
        return;
      }
      
      // CSV header with metadata
      const metadata = [
        `# BICEP Demo Export - ${new Date().toISOString()}`,
        `# Seed: ${currentSeed}`,
        `# Map Seed: ${currentMapSeed}`,
        `# Family: ${currentMapFamily}`,
        `# K: ${document.getElementById('particles').value}`,
        `# μ: ${document.getElementById('drift').value}`,
        `# σ: ${document.getElementById('sigma').value}`,
        `# ρ: ${document.getElementById('correlation').value}`,
        `# T: ${document.getElementById('horizon-slider').value}`,
        `# CVaR: ${document.getElementById('cvar-toggle').checked}`,
        ''  // empty line
      ];
      
      const csvLines = ['Path_ID,Cost,Risk_Score,Min_Clearance,Length,Waypoints'];
      
      winners.forEach((winner, i) => {
        const waypoints = winner.path.map(p => `(${p[0]},${p[1]})`).join(';');
        const riskScore = typeof winner.risk === 'number' ? winner.risk : 0;
        const minClearance = typeof winner.clearance === 'number' ? winner.clearance.toFixed(2) : '';
        csvLines.push(`${i},${winner.cost.toFixed(3)},${riskScore.toFixed(3)},${minClearance},${winner.path.length},"${waypoints}"`);
      });
      
      const csvContent = metadata.join('\n') + csvLines.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const link = document.createElement('a');
      link.download = `bicep-paths-${currentSeed}-${Date.now()}.csv`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }
    
    // Add tooltips to mode buttons
    const modeTooltips = {
      'particles': 'Live particle swarm showing active trajectories',
      'heatmap': 'Visit density heatmap of explored regions',
      'paths': 'Top-K survivor paths ranked by cost'
    };
    
    document.querySelectorAll('.mode-btn').forEach(btn => {
      const mode = btn.dataset.mode;
      if (modeTooltips[mode]) {
        btn.title = modeTooltips[mode];
      }
    });
    
    // RL Event handlers
    document.getElementById('train-btn').addEventListener('click', startTraining);
    document.getElementById('eval-btn').addEventListener('click', runEvaluation);
    document.getElementById('export-png').addEventListener('click', exportToPNG);
    document.getElementById('export-csv').addEventListener('click', exportToCSV);
    
    // Parameter sliders for RL
    ['beta', 'episodes'].forEach(id => {
      const input = document.getElementById(id);
      const valueId = id + '-value';
      
      input.addEventListener('input', () => {
        document.getElementById(valueId).textContent = input.value;
      });
    });
    
    // Initialize
    initCanvases();
    initGrid();
    loadFromURL();
    updateStats();
  </script>
</body>
</html>